unit uFunctions;

interface


uses
  System.Hash,
  Vcl.ComCtrls,
  System.SysUtils,  // Für TryStrToInt, DirectoryExists
  System.DateUtils, // Für TDateTime
  System.IOUtils,   // Für TDirectory
  System.RegularExpressions,
  Windows,
  StrUtils,
  Messages,
  IniFiles,
  Variants,
  Classes,
  Graphics,
  Controls,
  Forms,
  Math,
  Dialogs,
  Menus,
  System.Zip,
  StdCtrls,
  ExtCtrls,
  ShellApi,
  FileCtrl,
  System.UITypes,
  CryptBase,
  AESObj,
  MMSystem,
  VCL.FlexCel.Core,
  FlexCel.XlsAdapter,
  Vcl.Imaging.pngimage,
  IdIcmpClient, IdGlobal,
  ComObj;


procedure ScrollToRechnungsNr(ListView: TListView; AValue: Integer);
procedure ClearTempFolder;
function ReplaceUmlauteWithHtmlEntities(const InputString: string): string;
procedure CreateHtmlAndPdfFileFromResource(dateiname: string; stl: TStringList; ausrichtung: string = 'print_portrait.bat');
procedure SpeicherePDFDatei(filename, ZielVerzeichnis: string);
function GetAppVersion: string;
function GetFileVersion: string;
procedure SaveResourceToFile(ResourceName, FileName: string);
function CentToEuro(const ACent: Int64): string;
function EditToCentSafe(const AEdit: TLabeledEdit): Int64;
function EditTextToCent(const AEdit: TLabeledEdit): Int64;
procedure SelectComboBoxItemByText(CB: TComboBox; const AText: string);
function IsAllowedColumn(const Col: string): Boolean;
procedure ExportListViewToCSV(LV: TListView; const Filename: string;
  const ColumnOrder: array of Integer; const ColumnHeaders: array of string;
  const Separator: Char = ';');
procedure OpenCalculator;
function ExcelEuroToCent(const V: Variant): Int64;
function ExcelVariantToUnixDate(const V: OleVariant; out UnixTS: Int64): Boolean;
function TryParseDeDateTime(const S: string; out DT: TDateTime): Boolean;
procedure lvColumnClickForSort(Sender: TObject; Column: TListColumn);
procedure lvCompareForSort(Sender: TObject; Item1, Item2: TListItem; Data: Integer; var Compare: Integer);
function IsValidGermanDate(const S: string): Boolean;
function IsValidEuroAmount(const S: string): Boolean;
function IsPureInteger(const S: string): Boolean;
procedure ShowProgress(const OutputLabel: TLabel; const Msg: string);
function ReplaceUmlaute(const InputString: string): string;
function IsUpdateQuestionAllowed(const Ini: TIniFile): Boolean;
function DateStringToInteger(const S: string): Integer;
procedure ShowLongText(const ACaption, AText: string);
function ExtractNumber(const S: string): Integer;




implementation



uses
  uMain;


procedure ScrollToRechnungsNr(ListView: TListView; AValue: Integer);
var
  Item: TListItem;
begin
  for Item in ListView.Items do
  begin
    if StrToIntDef(Item.Caption, -1) = AValue then
    begin
      ListView.Selected := Item;
      Item.Focused := True;
      Item.MakeVisible(False); // False = nicht oben anpinnen
      Break;
    end;
  end;
end;


procedure ClearTempFolder;
var
  TempPath: string;
  FileName: string;
begin
  TempPath := TPath.Combine(
    ExtractFilePath(ParamStr(0)),
    'TEMP'
  );

  if not TDirectory.Exists(TempPath) then
    Exit;

  // Dateien löschen
  for FileName in TDirectory.GetFiles(TempPath) do
    TFile.Delete(FileName);

  // Unterordner löschen
  for FileName in TDirectory.GetDirectories(TempPath) do
    TDirectory.Delete(FileName, True);
end;




// Funktion zum Ersetzen von Umlauten durch HTML-Entities
function ReplaceUmlauteWithHtmlEntities(const InputString: string): string;
begin
  // Ersetzen Sie die Umlaute durch die entsprechenden HTML-Entities
  Result := StringReplace(InputString, 'ä', '&auml;', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'Ä', '&Auml;', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'ö', '&ouml;', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'Ö', '&Ouml;', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'ü', '&uuml;', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'Ü', '&Uuml;', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'ß', '&szlig;', [rfReplaceAll, rfIgnoreCase]);
end;




procedure ShowLongText(const ACaption, AText: string);
var
  F: TForm;
  M: TMemo;
begin
  F := TForm.Create(nil);
  try
    F.Caption := ACaption;
    F.Width := 700;
    F.Height := 200;
    F.Position := poScreenCenter;

    M := TMemo.Create(F);
    M.Parent := F;
    M.Align := alClient;
    M.ReadOnly := True;
    M.ScrollBars := ssBoth;
    M.WordWrap := False;
    M.Text := AText;

    F.ShowModal;
  finally
    F.Free;
  end;
end;




//Erzeugt aus einer Stringlist eine temporäre Html-Datei und daraus eine PDF Datei.
procedure CreateHtmlAndPdfFileFromResource(dateiname: string; stl: TStringList; ausrichtung: string = 'print_portrait.bat');
var
  MaxWaitTime: Integer;
  WaitInterval: Integer;
  TotalWaitTime: Integer;
  ScriptDatei, HtmlFile, PdfFile: string;
  CommandLine: string;
begin
  dateiname := ReplaceUmlaute(dateiname);

  ScriptDatei := TPath.Combine(PATHSCRIPTS, ausrichtung);
  HtmlFile    := TPath.Combine(PATHTEMP, dateiname + '.html');
  PdfFile     := TPath.Combine(PATHANKAUFSFORMULARE, dateiname + '.pdf');

  stl.SaveToFile(HTMLFile);  //Formular aus Resource als html-Datei speichern

  if not (FileExists(HTMLFile)) then
  begin
    ShowLongText('Datei konnte nicht erzeugt werden', HTMLFile);
    exit;
  end;

  CommandLine := Format('"%s" "%s"', [HtmlFile, PdfFile]);

  //PDF aus Html Datei erzeugen
  if ShellExecute(0, 'open', PChar(ScriptDatei), PChar(CommandLine), '', SW_HIDE) <= 32 then
  begin
    ShowMessage('Fehler beim Ausführen des Skripts zum erzeugen des PDF Formulars.');
  end;

  // Warten bis die Datei existiert (mit einem maximalen Timeout)
  MaxWaitTime   := 10000;  // Maximum Wartezeit in Millisekunden (z.B. 10 Sekunden = 10000)
  WaitInterval  := 1000;   // Warteintervall in Millisekunden (z.B. 500 ms)
  TotalWaitTime := 0;

  while not FileExists(PdfFile) do
  begin
    Sleep(WaitInterval);
    TotalWaitTime := TotalWaitTime + WaitInterval;
    if TotalWaitTime >= MaxWaitTime then
    begin
      ShowMessage('Fehler: Das erzeugen der PDF-Datei hat zu lang gedauert.');
      Exit;  // Beenden, wenn die Datei nicht innerhalb der MaxWaitTime erstellt wurde.
    end;
  end;

  if MessageDlg('Ankaufformular erfolgreich erzeugt.' + sLineBreak +
       'Möchten Sie das Ankaufformular im Datei-Explorer anzeigen?',
       mtConfirmation, [mbYes, mbNo], 0) = mrYes then
  begin
    if FileExists(PdfFile) then
      ShellExecute(0, 'open', 'explorer.exe', PChar('/select,"' + PdfFile + '"'), nil, SW_SHOWNORMAL);
  end;
end;








function ShortPath(const LongPath: string): string;
var
  Buffer: array[0..MAX_PATH] of Char;
begin
  if GetShortPathName(PChar(LongPath), Buffer, MAX_PATH) > 0 then
    Result := string(Buffer)
  else
    Result := LongPath; // Fallback: gib Original zurück, falls Umwandlung fehlschlägt
end;



//Eine PDF Datei am angegebenen Ort speichern
procedure SpeicherePDFDatei(filename, ZielVerzeichnis: string);
var
  SaveDialog: TSaveDialog;
  tempfile, pdffile: string;
begin
  filename := ReplaceUmlaute(filename); //Ohne Pfad und Erweiterung

  if not FileExists(PATHTEMP + '\' + filename + '.pdf') then
  begin
    ShowMessage('Die temporäre Datei wurde nicht gefunden:' + sLineBreak + filename);
    Exit;
  end;

  if not DirectoryExists(ZielVerzeichnis) then
  begin
    if MessageDlg('Bitte geben Sie in den Einstellungen den Pfad an, unter dem Sie die Datei ' + filename + ' abspeichern wollen!'+sLineBreak+sLineBreak+'Wollen Sie den Pfad jetzt angeben?', mtConfirmation, [mbYes, mbNo], 0, mbYes) = mrYes then
    begin
    showmessage('ANPASSEN in uFunctions');
      //fEinstellungen_Programm.Show;
      exit;
    end
    else
    begin
      exit;
    end;
  end;

  SaveDialog := TSaveDialog.Create(nil);
  try
    SaveDialog.DefaultExt := 'pdf';
    SaveDialog.Filter     := 'PDF-Dateien (*.pdf)|*.pdf';
    SaveDialog.InitialDir := IncludeTrailingPathDelimiter(ZielVerzeichnis);
    SaveDialog.FileName   := ReplaceUmlaute(filename) + '.pdf';

    if SaveDialog.Execute then
    begin
      try
        TFile.Copy(PATHTEMP + '\' + filename + '.pdf', SaveDialog.FileName, True); // True: Ziel überschreiben
        ShowMessage('Datei erfolgreich gespeichert unter:' + sLineBreak + SaveDialog.FileName);
      except
        on E: Exception do
          ShowMessage('Fehler beim Speichern der Datei:' + sLineBreak + E.Message);
      end;
    end;
  finally
    SaveDialog.Free;
  end;
end;




//Version des Programms ermitteln
function GetAppVersion: string;
var
  InfoSize, Wnd: DWORD;
  VerBuf: Pointer;
  VerData: Pointer;
  VerLen: UINT;
  VerKey: string;
  FileName: string;
begin
  Result := '';
  FileName := ParamStr(0);
  InfoSize := GetFileVersionInfoSize(PChar(FileName), Wnd);

  if InfoSize = 0 then Exit;

  GetMem(VerBuf, InfoSize);
  try
    if GetFileVersionInfo(PChar(FileName), 0, InfoSize, VerBuf) then
    begin
      VerKey := '\';
      if VerQueryValue(VerBuf, PChar(VerKey), VerData, VerLen) then
      begin
        with TVSFixedFileInfo(VerData^) do
        begin
          Result := Format('%d.%d.%d.%d',
            [HiWord(dwFileVersionMS), LoWord(dwFileVersionMS),
             HiWord(dwFileVersionLS), LoWord(dwFileVersionLS)]);
        end;
      end;
    end;
  finally
    FreeMem(VerBuf);
  end;
end;






function GetFileVersion: string;
var
  VerInfoSize, VerValueSize, Dummy: DWORD;
  VerInfo: Pointer;
  VerValue: PVSFixedFileInfo;
begin
  VerInfoSize := GetFileVersionInfoSize(PChar(ParamStr(0)), Dummy);
  if VerInfoSize = 0 then Exit('');

  GetMem(VerInfo, VerInfoSize);
  try
    if GetFileVersionInfo(PChar(ParamStr(0)), 0, VerInfoSize, VerInfo) then
    begin
      VerQueryValue(VerInfo, '\', Pointer(VerValue), VerValueSize);
      with VerValue^ do
        Result := Format('%d.%d.%d.%d', [
          HiWord(dwFileVersionMS), LoWord(dwFileVersionMS),
          HiWord(dwFileVersionLS), LoWord(dwFileVersionLS)]);
    end;
  finally
    FreeMem(VerInfo);
  end;
end;





procedure SaveResourceToFile(ResourceName, FileName: string);
var
  ResStream: TResourceStream;
  FileStream: TFileStream;
begin
  if not FileExists(FileName) then
  begin
    ResStream := TResourceStream.Create(HInstance, ResourceName, RT_RCDATA);
    try
      FileStream := TFileStream.Create(FileName, fmCreate);
      try
        FileStream.CopyFrom(ResStream, 0);
      finally
        FileStream.Free;
      end;
    finally
      ResStream.Free;
    end;
  end;
end;






function CentToEuro(const ACent: Int64): string;
begin
  Result := FormatFloat('0.00', ACent / 100.0);
end;








function EditToCent(const AEdit: TLabeledEdit): Int64;
var
  s: string;
begin
  s := Trim(AEdit.Text);

  if s = '' then
    Exit(0); // leer → 0 Cent

  Result := Round(StrToFloat(s) * 100);
end;




function EditToCentSafe(const AEdit: TLabeledEdit): Int64;
var
  Value: Double;
begin
  // Leer → 0
  if Trim(AEdit.Text) = '' then
    Exit(0);

  // Ungültig → 0 (keine Exception!)
  if not TryStrToFloat(AEdit.Text, Value) then
    Exit(0);

  Result := Round(Value * 100);
end;





function EditTextToCent(const AEdit: TLabeledEdit): Int64;
var
  Value: Double;
begin
  if not TryStrToFloat(Trim(AEdit.Text), Value) then
    Exit(0);

  Result := Round(Value * 100);
end;






procedure SelectComboBoxItemByText(CB: TComboBox; const AText: string);
var
  Index: Integer;
begin
  Index := CB.Items.IndexOf(AText);
  if Index <> -1 then
    CB.ItemIndex := Index;
end;



function IsAllowedColumn(const Col: string): Boolean;
begin
  Result :=
    SameText(Col, 'Einkaufsdatum') or
    SameText(Col, 'Verkaufsdatum') or
    SameText(Col, 'SKU') or
    SameText(Col, 'Einheit') or
    SameText(Col, 'RechnungsNr');
end;




procedure ExportListViewToCSV(LV: TListView; const Filename: string;
  const ColumnOrder: array of Integer; const ColumnHeaders: array of string;
  const Separator: Char = ';');
var
  CSVFile: TStringList;
  i, j: Integer;
  Line: string;
  Item: TListItem;
  Value: string;
  ini: TIniFile;
begin
  if Length(ColumnOrder) <> Length(ColumnHeaders) then
  begin
    ShowMessage('ColumnOrder und ColumnHeaders müssen gleich lang sein!');
    Exit;
  end;

  CSVFile := TStringList.Create;
  try
    // Header schreiben
    Line := '';
    for j := 0 to High(ColumnHeaders) do
    begin
      if j > 0 then Line := Line + Separator;
      Line := Line + '"' + ColumnHeaders[j] + '"';
    end;
    CSVFile.Add(Line);

    // Daten schreiben
    for i := 0 to LV.Items.Count - 1 do
    begin
      Item := LV.Items[i];
      Line := '';

      for j := 0 to High(ColumnOrder) do
      begin
        if j > 0 then Line := Line + Separator;

        if ColumnOrder[j] = -1 then
          Value := Item.Caption
        else if ColumnOrder[j] < Item.SubItems.Count then
          Value := Item.SubItems[ColumnOrder[j]]
        else
          Value := '';

        // Einfach den Text aus der ListView nehmen, so wie er angezeigt wird
        Line := Line + '"' + Value + '"';
      end;

      CSVFile.Add(Line);
    end;

    CSVFile.SaveToFile(Filename, TEncoding.UTF8);

    ini := TIniFile.Create(PATH + 'settings.ini');
    try
      ini.WriteInteger('DATENEXPORT','LastExport', Trunc(Now));
      fMain.LoadStatusBarValues;
    finally
      ini.Free;
    end;
  finally
    CSVFile.Free;

    if(FileExists(Filename)) then
      showmessage('Inventarliste wurde erfolgreich exportiert!')
    else
      showmessage('Beim Export der Inventarliste ist wohl was schief gelaufen!');
  end;
end;




procedure OpenCalculator;
begin
  ShellExecute(0, 'open', 'ms-calculator:', nil, nil, SW_SHOWNORMAL);
end;






function ExcelEuroToCent(const V: Variant): Int64;
var
  S: string;
  F: Double;
  FS: TFormatSettings;
begin
  Result := 0;

  if VarIsNull(V) or VarIsEmpty(V) then
    Exit;

  S := Trim(VarToStr(V));

  if S = '' then
    Exit;

  // Euro-Zeichen & Leerzeichen entfernen
  S := StringReplace(S, '€', '', [rfReplaceAll]);
  S := StringReplace(S, ' ', '', [rfReplaceAll]);

  FS := TFormatSettings.Create;
  FS.DecimalSeparator := ',';
  FS.ThousandSeparator := '.';

  if TryStrToFloat(S, F, FS) then
    Result := Round(F * 100);
end;





function ExcelVariantToUnixDate(const V: OleVariant; out UnixTS: Int64): Boolean;
var
  DT: TDateTime;
begin
  // Default: 01.01.1970
  UnixTS := 0;
  Result := True;

  // leer → 01.01.1970
  if VarIsNull(V) or VarIsEmpty(V) then
    Exit;

  // echtes Excel-Datum
  if VarType(V) = varDate then
  begin
    DT := VarAsType(V, varDate);
    UnixTS := DateTimeToUnix(DT);
    Exit;
  end;

  // alles andere (Text!) → ignorieren
  // egal ob "Unbekannt", "UNBEKANNT", ".01.07.2025", etc.
end;





function TryParseDeFloat(const S: string; out V: Double): Boolean;
var
  FS: TFormatSettings;
  T: string;
begin
  FS := TFormatSettings.Create('de-DE');

  T := Trim(S);

  if T = '' then
    Exit(False);

  // evtl. Euro-Zeichen entfernen
  T := StringReplace(T, '€', '', [rfReplaceAll]);
  T := Trim(T);

  Result := TryStrToFloat(T, V, FS);
end;




//Zum sortieren von Listviews nach Datum + Zeit
function TryParseDeDateTime(const S: string; out DT: TDateTime): Boolean;
var
  FS: TFormatSettings;
begin
  FS := TFormatSettings.Create('de-DE');
  FS.DateSeparator   := '.';
  FS.TimeSeparator   := ':';
  FS.ShortDateFormat := 'dd.mm.yyyy';

  // 1. mit Sekunden versuchen
  FS.ShortTimeFormat := 'hh:nn:ss';
  Result := TryStrToDateTime(S, DT, FS);

  // 2. ohne Sekunden fallback
  if not Result then
  begin
    FS.ShortTimeFormat := 'hh:nn';
    Result := TryStrToDateTime(S, DT, FS);
  end;
end;




procedure lvColumnClickForSort(Sender: TObject; Column: TListColumn);
begin
  ColumnToSort := Column.Index;
  if ColumnToSort = LastSorted then
    SortDir := 1 - SortDir
  else
    SortDir := 0;
  LastSorted := ColumnToSort;

  // Nur sortieren, wenn es durch Benutzerinteraktion ausgelöst wurde
  if Sender is TCustomListView then
    (Sender as TCustomListView).AlphaSort;
end;





procedure lvCompareForSort(
  Sender: TObject;
  Item1, Item2: TListItem;
  Data: Integer;
  var Compare: Integer
);
var
  S1, S2: string;
  F1, F2: Double;
  Has1, Has2: Boolean;
  D1, D2: TDateTime;
  ColTag: Integer;
  IsEmptyDecision: Boolean;
begin
  IsEmptyDecision := False;

  // Text ermitteln
  if ColumnToSort = 0 then
  begin
    S1 := Trim(Item1.Caption);
    S2 := Trim(Item2.Caption);
  end
  else
  begin
    S1 := Trim(Item1.SubItems[ColumnToSort - 1]);
    S2 := Trim(Item2.SubItems[ColumnToSort - 1]);
  end;

  ColTag := (Sender as TListView).Columns[ColumnToSort].Tag;

  case ColTag of
    // ===== ZAHLEN =====
    1, 2:
    begin
      Has1 := TryStrToFloat(S1, F1);
      Has2 := TryStrToFloat(S2, F2);

      if not Has1 and not Has2 then
      begin
        Compare := 0;
        IsEmptyDecision := True;
      end
      else if not Has1 then
      begin
        Compare := 1;              // leer immer unten
        IsEmptyDecision := True;
      end
      else if not Has2 then
      begin
        Compare := -1;
        IsEmptyDecision := True;
      end
      else
        Compare := CompareValue(F1, F2);
    end;

    // ===== DATUM =====
    3:
    begin
      Has1 := TryParseDeDateTime(S1, D1);
      Has2 := TryParseDeDateTime(S2, D2);

      if not Has1 and not Has2 then
      begin
        Compare := 0;
        IsEmptyDecision := True;
      end
      else if not Has1 then
      begin
        Compare := 1;
        IsEmptyDecision := True;
      end
      else if not Has2 then
      begin
        Compare := -1;
        IsEmptyDecision := True;
      end
      else
        Compare := CompareValue(D1, D2);
    end;

  else
    Compare := AnsiCompareText(S1, S2);
  end;

  // 🔒 SortDir NUR anwenden, wenn kein Leer-Vergleich
  if (SortDir = 1) and (not IsEmptyDecision) then
    Compare := -Compare;
end;



















function IsValidGermanDate(const S: string): Boolean;
var
  DT: TDateTime;
  FS: TFormatSettings;
begin
  FS := TFormatSettings.Create('de-DE');
  FS.DateSeparator := '.';

  // zuerst dd.mm.yyyy versuchen
  FS.ShortDateFormat := 'dd.mm.yyyy';
  if TryStrToDate(S, DT, FS) then
    Exit(True);

  // dann dd.mm.yy versuchen
  FS.ShortDateFormat := 'dd.mm.yy';
  Result := TryStrToDate(S, DT, FS);
end;




function IsValidEuroAmount(const S: string): Boolean;
var
  T: string;
  F: Double;
begin
  T := Trim(S);

  if T = '' then
    Exit(False);

  T := StringReplace(T, '€', '', [rfReplaceAll]);
  T := StringReplace(T, 'EUR', '', [rfReplaceAll, rfIgnoreCase]);
  T := StringReplace(T, ' ', '', [rfReplaceAll]);
  T := StringReplace(T, '.', '', [rfReplaceAll]); // Tausender
  T := StringReplace(T, ',', '.', [rfReplaceAll]); // Dezimal

  Result := TryStrToFloat(T, F, TFormatSettings.Invariant);
end;




function IsPureInteger(const S: string): Boolean;
var
  I: Integer;
begin
  Result := TryStrToInt(S, I);
end;








procedure ShowProgress(const OutputLabel: TLabel; const Msg: string);
begin
  if Assigned(OutputLabel) then
  begin
    OutputLabel.Caption := Msg;
    Application.ProcessMessages;
  end;
end;





function ReplaceUmlaute(const InputString: string): string;
begin
  Result := StringReplace(InputString, 'ä', 'ae', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'Ä', 'Ae', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'ö', 'oe', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'Ö', 'Oe', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'ü', 'ue', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'Ü', 'Ue', [rfReplaceAll, rfIgnoreCase]);
  Result := StringReplace(Result, 'ß', 'ss', [rfReplaceAll, rfIgnoreCase]);
end;







function IsUpdateQuestionAllowed(const Ini: TIniFile): Boolean;
var
  LastAskedDate: Integer;
begin
  Result := True; // Standard: erlauben

  if not Ini.ValueExists('UPDATE', 'InstallUpdateQuestion') then
    Exit;

  LastAskedDate :=
    Ini.ReadInteger('UPDATE', 'InstallUpdateQuestion', 0);

  // ⏱ mindestens 7 Tage vergangen?
  Result := (Trunc(Date) - LastAskedDate) >= 7;
end;





function DateStringToInteger(const S: string): Integer;
var
  D: TDateTime;
begin
  if TryStrToDate(S, D) then
    Result := Trunc(D)
  else
    raise Exception.Create('Datum muss im Format dd.mm.yyyy sein');
end;




function ExtractNumber(const S: string): Integer;
var
  I: Integer;
begin
  I := 1;

  // alles überspringen, was keine Ziffer ist
  while (I <= Length(S)) and not CharInSet(S[I], ['0'..'9']) do
    Inc(I);

  // führende Nullen überspringen
  while (I <= Length(S)) and (S[I] = '0') do
    Inc(I);

  Result := StrToIntDef(Copy(S, I, MaxInt), 0);
end;






end.
