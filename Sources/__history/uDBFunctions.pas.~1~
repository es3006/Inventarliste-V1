unit uDBFunctions;

interface

uses
  Windows, Classes, Forms, System.SysUtils, Vcl.StdCtrls, Vcl.ComCtrls, Dialogs, Controls, ExtCtrls, DateUtils,
  Graphics, StrUtils, ShellApi, System.UITypes, System.Zip, System.IOUtils, System.Types, System.Generics.Collections,
  FireDAC.Stan.Param, FireDAC.Phys.SQLite, Data.DB, FireDAC.Comp.DataSet, FireDAC.Comp.Client, System.Generics.Defaults,
  FireDAC.Stan.Intf, FireDAC.DApt,
  ComObj, Variants;



procedure CreateDatabaseTables;
function GetLastSKU(const AConnection: TFDConnection; const Ankaufformular: boolean = false): string;
function GetNextSKU(const AConnection: TFDConnection; const Ankaufformular: boolean = false): string;
function GetLastKdNr(const AConnection: TFDConnection): string;
function GetNextKdNr(const AConnection: TFDConnection): string;
function GetKundenNrByID(const AConnection: TFDConnection): string;
procedure LoadEinheitenFromDB(const AConnection: TFDConnection; cb: TComboBox);
procedure LoadZustaendeFromDB(const AConnection: TFDConnection; cb: TComboBox);
procedure LoadZahlungsartenFromDB(const AConnection: TFDConnection; cb: TComboBox);
function LoadCountEntriesBySKUFromDB(const AConnection: TFDConnection; SKU: String): integer;
procedure AddEinheitIfNotExists(const AConnection: TFDConnection; const AEinheit: string);
procedure DeleteInventar(const AConnection: TFDConnection);
procedure DeleteEntryFromInventar(const AConnection: TFDConnection; const ENTRYID: Integer);
procedure DeleteEntryFromKunden(const AConnection: TFDConnection; const ENTRYID: Integer);
procedure DeleteEntryFromAnkaeufe(const AConnection: TFDConnection; const ENTRYID: Integer);
procedure CreateDailyDatabaseDumpWithPrompt(const AConnection: TFDConnection);
procedure RestoreDatabaseFromBackup(const AConnection: TFDConnection);
procedure CreateManualDatabaseDump(const AConnection: TFDConnection);
procedure ImportExcelToInventar(const AConnection: TFDConnection; const ExcelFile: string; OutputLabel: TLabel);
procedure ImportCSVToInventar(const AConnection: TFDConnection; const CSVFile: string; OutputLabel: TLabel);




implementation

uses
  uMain, uFunctions;




{
  Datenbanktabellen erstellen wenn noch keine Datenbank vorhanden oder eine der
  Tabellen noch nicht in der Datenbank existiert.
}
procedure CreateDatabaseTables;
const
  Einheiten: array[0..17] of string = ('0,5g','1g','2g','2,5g','4g','5g','1/4oz','10g','15g','20g', '25g','1oz','50g','100g','250g','500g','1000g','2500g');
  Zustaende: array[0..3] of string = ('Neu', 'Neuwertig', 'Gebraucht', 'Defekt');
  Zahlungsarten: array[0..1] of string = ('Überweisung', 'Barzahlung');
var
  FDQuery: TFDQuery;
  S: string;
  i: integer;
begin
  FDQuery := TFDQuery.Create(nil);
  try
    FDQuery.Connection := fMain.FDConnection1;
    fMain.FDConnection1.StartTransaction;
    try
      // Einheiten
      FDQuery.ExecSQL(
        'CREATE TABLE IF NOT EXISTS einheiten (' +
        'id INTEGER PRIMARY KEY AUTOINCREMENT, ' +
        'position INTEGER, ' +
        'einheit TEXT NOT NULL UNIQUE)'
      );

      FDQuery.SQL.Text := 'INSERT OR IGNORE INTO einheiten (position, einheit) VALUES (:POSITION, :EINHEIT)';

      // Parameter definieren (wichtig!)
      with FDQuery.ParamByName('POSITION') do
      begin
        DataType := ftInteger;
        ParamType := ptInput;
      end;

      with FDQuery.ParamByName('EINHEIT') do
      begin
        DataType := ftString;
        ParamType := ptInput;
      end;

      FDQuery.Prepare;

      for i := Low(Einheiten) to High(Einheiten) do
      begin
        FDQuery.ParamByName('POSITION').AsInteger := i+1;
        FDQuery.ParamByName('EINHEIT').AsString   := Einheiten[i];
        FDQuery.ExecSQL;
      end;

      // Inventar
      FDQuery.ExecSQL(
        'CREATE TABLE IF NOT EXISTS inventar (' +
        'id INTEGER PRIMARY KEY AUTOINCREMENT, ' +
        'Einkaufsdatum INTEGER, ' +
        'SKU TEXT, ' +
        'Einkaufswert INTEGER NOT NULL DEFAULT 0, ' +
        'EinkaufBemerkung TEXT, ' +
        'Verkaufsdatum INTEGER, ' +
        'Verkaufswert INTEGER NOT NULL DEFAULT 0, ' +
        'VerkaufBemerkung TEXT, ' +
        'Steuerbetrag INTEGER NOT NULL DEFAULT 0, ' +
        'RechnungsNr TEXT, ' +
        'Einheit TEXT, ' +
        'AnkaufformularID INTEGER DEFAULT 0)'
      );



      // Kundenankauf
      FDQuery.ExecSQL(
        'CREATE TABLE IF NOT EXISTS kundenankauf (' +
        'id INTEGER PRIMARY KEY AUTOINCREMENT, ' +
        'kundenID INTEGER NOT NULL, ' +
        'Ankaufsdatum INTEGER NOT NULL DEFAULT 0, ' +
        'SKU TEXT, ' +
        'Ref TEXT, ' +
        'Box INTEGER DEFAULT 0, ' +
        'Papiere INTEGER DEFAULT 0, ' +
        'Marke TEXT, ' +
        'Model TEXT, ' +
        'Jahr INTEGER NOT NULL DEFAULT 0, ' +
        'Kaufpreis INTEGER NOT NULL DEFAULT 0, ' +
        'Zustand TEXT, ' +
        'Bezeichnung TEXT, ' +
        'Gewicht TEXT, ' +
        'Versand INTEGER NOT NULL DEFAULT 0, ' +
        'Zahlungsart TEXT NOT NULL, ' +
        'SavedInInventar INTEGER DEFAULT 0)'
      );


      // Kundendaten
      FDQuery.ExecSQL(
        'CREATE TABLE IF NOT EXISTS kundendaten (' +
        'id INTEGER PRIMARY KEY AUTOINCREMENT, ' +
        'kundenNr TEXT NOT NULL UNIQUE, ' +
        'Nachname TEXT NOT NULL, ' +
        'Vorname TEXT NOT NULL, ' +
        'StrasseHausNr TEXT, ' +
        'PLZ TEXT, ' +
        'Ort TEXT, ' +
        'Telefon TEXT, ' +
        'Handy TEXT, ' +
        'Email Text, ' +
        'AusweisNr TEXT UNIQUE, ' +
        'Geburtsdatum INTEGER DEFAULT 0)'
      );


      // Zustaende
      FDQuery.ExecSQL(
        'CREATE TABLE IF NOT EXISTS zustaende (' +
        'id INTEGER PRIMARY KEY AUTOINCREMENT, ' +
        'position INTEGER NOT NULL DEFAULT 0, ' +
        'Zustand TEXT NOT NULL UNIQUE)'
      );

      FDQuery.SQL.Text := 'INSERT OR IGNORE INTO zustaende (position, Zustand) VALUES (:POSITION, :ZUSTAND)';

      for i := Low(Zustaende) to High(Zustaende) do
      begin
        FDQuery.ParamByName('POSITION').AsInteger := i+1;
        FDQuery.ParamByName('ZUSTAND').AsString := Zustaende[i];
        FDQuery.ExecSQL;
      end;


      // Zahlungsarten
      FDQuery.ExecSQL(
        'CREATE TABLE IF NOT EXISTS zahlungsarten (' +
        'id INTEGER PRIMARY KEY AUTOINCREMENT, ' +
        'Zahlungsart TEXT NOT NULL UNIQUE)'
      );

      FDQuery.SQL.Text := 'INSERT OR IGNORE INTO zahlungsarten (Zahlungsart) VALUES (:ZAHLUNGSART)';

      for i := Low(Zahlungsarten) to High(Zahlungsarten) do
      begin
        FDQuery.ParamByName('ZAHLUNGSART').AsString := Zahlungsarten[i];
        FDQuery.ExecSQL;
      end;


      fMain.FDConnection1.Commit;
    except
      fMain.FDConnection1.Rollback;
      raise;
    end;
  finally
    FDQuery.Free;
  end;
end;










function GetLastSKU(const AConnection: TFDConnection; const Ankaufformular: boolean = false): string;
var
  Q: TFDQuery;
  MaxNum: Integer;
begin
  Result := '';

  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;

//Ankaufsformular
    if(Ankaufformular = true) then
    begin
      Q.SQL.Text :=
        'SELECT MAX(CAST(SUBSTR(SKU, 3) AS INTEGER)) AS MaxSKU ' +
        'FROM kundenankauf ' +
        'WHERE SKU LIKE ''AK%''';
      Q.Open;

      if not Q.FieldByName('MaxSKU').IsNull then
      begin
        MaxNum := Q.FieldByName('MaxSKU').AsInteger;
        Result := 'AK' + Format('%.6d', [MaxNum]);
      end
      else
      begin
        Result := STARTSKU_ANKAUF;
      end;
    end
    else
    begin
//Wareneinkauf (Inventarliste)
      Q.SQL.Text :=
        'SELECT MAX(CAST(SUBSTR(SKU, 3) AS INTEGER)) AS MaxSKU ' +
        'FROM inventar ' +
        'WHERE SKU LIKE ''TG%''';
      Q.Open;

      if not Q.FieldByName('MaxSKU').IsNull then
      begin
        MaxNum := Q.FieldByName('MaxSKU').AsInteger;
        Result := 'TG' + Format('%.6d', [MaxNum]);
      end
      else
      begin
        Result := STARTSKU_EINKAUF;
      end;
    end;
  finally
    Q.Free;
  end;
end;





function GetLastKdNr(const AConnection: TFDConnection): string;
var
  Q: TFDQuery;
  MaxNum: Integer;
begin
  Result := STARTKUNDENNR;

  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;
    Q.SQL.Text :=
      'SELECT MAX(CAST(SUBSTR(KundenNr, 3) AS INTEGER)) AS MaxKdNr ' +
      'FROM kundendaten ' +
      'WHERE KundenNr LIKE ''KD%''';

    Q.Open;

    if not Q.FieldByName('MaxKdNr').IsNull then
    begin
      MaxNum := Q.FieldByName('MaxKdNr').AsInteger;
      Result := Format('%.6d', [MaxNum]);
    end
    else
    begin
      // Falls noch kein Eintrag existiert
      Result := STARTKUNDENNR;
    end;

  finally
    Q.Free;
  end;
end;



function GetNextKdNr(const AConnection: TFDConnection): string;
var
  Q: TFDQuery;
  MaxNum: Integer;
begin
  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;
    Q.SQL.Text :=
      'SELECT MAX(CAST(SUBSTR(KundenNr, 6) AS INTEGER)) ' +
      'FROM kundendaten WHERE KundenNr LIKE ''%''';
    Q.Open;

    if Q.Fields[0].IsNull then
      MaxNum := 0
    else
      MaxNum := Q.Fields[0].AsInteger;

    Inc(MaxNum); // **einmal erhöhen, garantiert korrekt**

    Result := 'KD' + Format('%.6d', [MaxNum]);
  finally
    Q.Free;
  end;
end;








function GetKundenNrByID(const AConnection: TFDConnection): string;
var
  Q: TFDQuery;
begin
  Result := '';

  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;
    Q.SQL.Text :=
      'SELECT KundenNr FROM kundendaten WHERE id = :ID';

    Q.Open;

    if not Q.FieldByName('KundenNr').IsNull then
    begin
      Result := Q.FieldByName('KundenNr').AsString;
    end
    else
    begin
      Result := '';
    end;

  finally
    Q.Free;
  end;
end;





procedure LoadEinheitenFromDB(const AConnection: TFDConnection; cb: TComboBox);
var
  Q: TFDQuery;
begin
  CB.Items.Clear;

  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;
    Q.SQL.Text := 'SELECT id, position, einheit FROM einheiten ORDER BY position ASC';
    Q.Open;

    while not Q.Eof do
    begin
      CB.Items.Add(Q.FieldByName('Einheit').AsString);
      Q.Next;
    end;
  finally
    Q.Free;
  end;
end;





procedure LoadZustaendeFromDB(const AConnection: TFDConnection; cb: TComboBox);
var
  Q: TFDQuery;
begin
  cb.Items.Clear;

  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;
    Q.SQL.Text := 'SELECT id, Zustand FROM zustaende ORDER BY Zustand ASC';
    Q.Open;

    while not Q.Eof do
    begin
      cb.Items.AddObject(Q.FieldByName('Zustand').AsString, TObject(Q.FieldByName('id').AsInteger));
      Q.Next;
    end;
  finally
    Q.Free;
  end;
end;






procedure LoadZahlungsartenFromDB(const AConnection: TFDConnection; cb: TComboBox);
var
  Q: TFDQuery;
begin
  cb.Items.Clear;

  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;
    Q.SQL.Text := 'SELECT id, Zahlungsart FROM zahlungsarten ORDER BY Zahlungsart ASC';
    Q.Open;

    while not Q.Eof do
    begin
      cb.Items.AddObject(Q.FieldByName('Zahlungsart').AsString, TObject(Q.FieldByName('id').AsInteger));
      Q.Next;
    end;
  finally
    Q.Free;
  end;
end;






function GetNextSKU(const AConnection: TFDConnection; const Ankaufformular: boolean = false): string;
var
  LastSKU: string;
  Num: Integer;
begin
  LastSKU := GetLastSKU(AConnection, Ankaufformular);

  Num := StrToIntDef(Copy(LastSKU, 3), 0);
  Inc(Num);

  if(Ankaufformular = false) then
    Result := 'TG' + Format('%.6d', [Num])
  else
    Result := 'AK' + Format('%.6d', [Num])
end;




function LoadCountEntriesBySKUFromDB(const AConnection: TFDConnection; SKU: String): integer;
var
  Q: TFDQuery;
begin
  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;
    Q.SQL.Text := 'SELECT count(*) AS CNT FROM inventar WHERE sku = :SKU';

    // Parametertyp explizit setzen
    Q.ParamByName('SKU').DataType := ftString;

    // Dann Wert zuweisen
    Q.ParamByName('SKU').AsString := SKU;

    // Abfrage öffnen
    Q.Open;

    if not Q.IsEmpty then
    begin
      result := Q.FieldByName('CNT').AsInteger;
    end
    else
    begin
      result := 0;
    end;
  finally
    Q.Free;
  end;
end;






procedure AddEinheitIfNotExists(const AConnection: TFDConnection; const AEinheit: string);
var
  Q: TFDQuery;
begin
  if Trim(AEinheit) = '' then
    Exit;

  Q := TFDQuery.Create(nil);
  try
    Q.Connection := fMain.FDConnection1;

    // INSERT mit nächster Position in einer SQL-Anweisung
    Q.SQL.Text :=
      'INSERT OR IGNORE INTO einheiten (position, einheit) ' +
      'VALUES ((SELECT COALESCE(MAX(position),0) + 1 FROM einheiten), :EINHEIT)';

    Q.ParamByName('EINHEIT').AsString := Trim(AEinheit);

    Q.ExecSQL;

  finally
    Q.Free;
  end;
end;




//Alle Einträge aus der Tabelle inventar löschen
procedure DeleteInventar(const AConnection: TFDConnection);
var
  Q: TFDQuery;
begin
  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;
    Q.SQL.Text := 'DELETE FROM inventar';
    Q.ExecSQL;

    fMain.lvInventar.Items.Clear;

  finally
    Q.Free;
  end;
end;





procedure DeleteEntryFromInventar(const AConnection: TFDConnection; const ENTRYID: Integer);
var
  Q: TFDQuery;
begin
  if ENTRYID <= 0 then
    Exit;

  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;

    // INSERT mit nächster Position in einer SQL-Anweisung
    Q.SQL.Text :=
      'DELETE FROM inventar WHERE id = :ID';

    Q.ParamByName('ID').AsInteger := ENTRYID;

    Q.ExecSQL;

    uMain.ListViewDirty := True;

  finally
    Q.Free;
  end;
end;




procedure DeleteEntryFromKunden(const AConnection: TFDConnection; const ENTRYID: Integer);
var
  Q: TFDQuery;
begin
  if ENTRYID <= 0 then
    Exit;

  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;

    // INSERT mit nächster Position in einer SQL-Anweisung
    Q.SQL.Text :=
      'DELETE FROM kundendaten WHERE id = :ID';

    Q.ParamByName('ID').AsInteger := ENTRYID;

    Q.ExecSQL;

  finally
    Q.Free;
  end;
end;





procedure DeleteEntryFromAnkaeufe(const AConnection: TFDConnection; const ENTRYID: Integer);
var
  Q: TFDQuery;
  InventarCount: Integer;
  DeleteInventar: Boolean;
begin
  if ENTRYID <= 0 then
    Exit;

  DeleteInventar := False;

  Q := TFDQuery.Create(nil);
  try
    Q.Connection := AConnection;

    // 1) Prüfen, ob Eintrag in inventar existiert
    Q.SQL.Text :=
      'SELECT COUNT(*) FROM inventar ' +
      'WHERE AnkaufformularID = :ID';
    Q.ParamByName('ID').AsInteger := ENTRYID;
    Q.Open;

    InventarCount := Q.Fields[0].AsInteger;
    Q.Close;

    // 2) Nachfragen, falls Inventar-Einträge existieren
    if InventarCount > 0 then
    begin
      DeleteInventar :=
        MessageDlg(
          'Zu diesem Ankauf existiert ein Eintrag in der Inventarliste.' + sLineBreak +
          'Soll dieser ebenfalls gelöscht werden?',
          mtConfirmation,
          [mbYes, mbNo],
          0
        ) = mrYes;
    end;

    // 3) Löschen mit Transaktion
    AConnection.StartTransaction;
    try
      if DeleteInventar then
      begin
        Q.SQL.Text :=
          'DELETE FROM inventar ' +
          'WHERE AnkaufformularID = :ID';
        Q.ParamByName('ID').AsInteger := ENTRYID;
        Q.ExecSQL;
      end;

      Q.SQL.Text :=
        'DELETE FROM kundenankauf ' +
        'WHERE id = :ID';
      Q.ParamByName('ID').AsInteger := ENTRYID;
      Q.ExecSQL;

      AConnection.Commit;
    except
      AConnection.Rollback;
      raise;
    end;

  finally
    Q.Free;
  end;
end;







procedure CreateDailyDatabaseDumpWithPrompt(const AConnection: TFDConnection);
const
  MAX_DUMPS = 10;
var
  DumpDir: string;
  DumpFileName: string;
  DumpFiles: TArray<string>;
  DBFile: string;
  i: Integer;
  CreateDump: Boolean;
begin
  DumpDir := PATH + 'Sicherungen\';
  ForceDirectories(DumpDir);

  DBFile := AConnection.Params.Values['Database'];

  // Name des Dumps für den aktuellen Tag
  DumpFileName := DumpDir + 'Dump_' + FormatDateTime('yyyymmdd', Date) + ExtractFileExt(DBFile);

  // Prüfen, ob heute schon ein Dump existiert
  if uMain.ListViewDirty = true then
  begin
    if FileExists(DumpFileName) then
    begin
      if MessageDlg('Es existiert bereits ein Dump für heute.' + sLineBreak +
                    'Möchten Sie eine Datenbanksicherung des aktuellen Bestandes erstellen und die alte Version von heute überschreiben?',
                    mtConfirmation,
                    [mbYes, mbNo],
                    0) = mrYes then
        CreateDump := True
      else
        CreateDump := False;
    end;
  end
  else
    CreateDump := True;

  if CreateDump then
  begin
    // Verbindung kurz schließen, sonst Kopieren fehlschlägt
    if AConnection.Connected then
      AConnection.Connected := False;

    // Dump erstellen (überschreibt vorhandene Datei)
    CopyFile(PChar(DBFile), PChar(DumpFileName), False);

    AConnection.Connected := True;
  end;

  // Alte Dumps aufräumen (maximal 10)
  DumpFiles := TDirectory.GetFiles(DumpDir, 'Dump_*.sqlite');

  if Length(DumpFiles) > MAX_DUMPS then
  begin
    // Nach Name sortieren (älteste zuerst)
    TArray.Sort<string>(DumpFiles,
      TComparer<string>.Construct(
        function(const L, R: string): Integer
        begin
          Result := CompareText(L, R);
        end
      )
    );

    for i := 0 to Length(DumpFiles) - MAX_DUMPS - 1 do
      TFile.Delete(DumpFiles[i]);
  end;
end;







procedure RestoreDatabaseFromBackup(const AConnection: TFDConnection);
var
  OpenDlg: TOpenDialog;
  BackupFile: string;
  DBFile: string;
  TempBackup: string;
begin
  DBFile := AConnection.Params.Values['Database'];

  OpenDlg := TOpenDialog.Create(nil);
  try
    OpenDlg.Title := 'Datenbank-Sicherung auswählen zum Wiederherstellen';
    OpenDlg.Filter := 'SQLite Datenbank (*.s3db;*.sqlite;*.db)|*.s3db;*.sqlite;*.db|Alle Dateien|*.*';
    OpenDlg.InitialDir := PATH + 'Sicherungen\';

    if OpenDlg.Execute then
    begin
      BackupFile := OpenDlg.FileName;

      // Verbindung schließen, sonst Kopieren fehlschlägt
      if AConnection.Connected then
        AConnection.Connected := False;

      // Optional: aktuelle DB sichern, falls etwas schief geht
      TempBackup := DBFile + '.bak';
      if FileExists(DBFile) then
        CopyFile(PChar(DBFile), PChar(TempBackup), False);

      try
        // Backup in die echte Datenbank kopieren
        CopyFile(PChar(BackupFile), PChar(DBFile), False);

        ShowMessage('Backup erfolgreich wiederhergestellt: ' + ExtractFileName(BackupFile));
      except
        on E: Exception do
        begin
          // Restore der alten DB, falls Fehler
          if FileExists(TempBackup) then
            CopyFile(PChar(TempBackup), PChar(DBFile), False);

          raise Exception.Create('Fehler beim Wiederherstellen des Backups: ' + E.Message);
        end;
      end;

      // Alte Sicherung löschen (optional)
      if FileExists(TempBackup) then
        DeleteFile(TempBackup);

      // Verbindung wieder öffnen
      AConnection.Connected := True;
    end;
  finally
    OpenDlg.Free;
  end;
end;






procedure CreateManualDatabaseDump(const AConnection: TFDConnection);
var
  SaveDlg: TSaveDialog;
  DumpFileName: string;
  DBFile: string;
begin
  DBFile := AConnection.Params.Values['Database'];

  SaveDlg := TSaveDialog.Create(nil);
  try
    SaveDlg.Title := 'Datenbank-Sicherung erstellen';
    SaveDlg.InitialDir := PATH + 'Sicherungen\';
    SaveDlg.Filter := 'SQLite Datenbank (*.s3db;*.sqlite;*.db)|*.s3db;*.sqlite;*.db|Alle Dateien|*.*';
    SaveDlg.DefaultExt := 'sqlite';
    SaveDlg.FileName := 'Dump_' + FormatDateTime('yyyymmdd', Date) + ExtractFileExt(DBFile);

    if SaveDlg.Execute then
    begin
      DumpFileName := SaveDlg.FileName;

      // Verbindung kurz schließen
      if AConnection.Connected then
        AConnection.Connected := False;

      // Dump erstellen (überschreibt vorhandene Datei, falls Name identisch)
      CopyFile(PChar(DBFile), PChar(DumpFileName), False);

      // Verbindung wieder öffnen
      AConnection.Connected := True;

      ShowMessage('Datenbank-Dump erfolgreich erstellt:' + sLineBreak + DumpFileName);
    end;
  finally
    SaveDlg.Free;
  end;
end;












procedure ImportExcelToInventar(const AConnection: TFDConnection; const ExcelFile: string; OutputLabel: TLabel);
var
  Excel, Workbook, Sheet: OleVariant;
  Row: Integer;

  KaufDT, VerkaufDT: TDateTime;
  TSKauf, TSVerkauf: Int64;

  SKU, RechnungsNr, Einheit, EinkaufBemerkung, VerkaufsBemerkung, S7, S8: string;
  EinkaufswertCent, VerkaufswertCent, SteuerbetragCent: Int64;

  function IsPureInteger(const S: string): Boolean;
  var
    I: Integer;
  begin
    Result := TryStrToInt(S, I);
  end;

begin
  // Sofort Meldung ausgeben, bevor Excel geladen wird
  ShowProgress(OutputLabel, 'Import der Exceldatei in die Datenbank wird vorbereitet...');

  Excel := CreateOleObject('Excel.Application');
  try
    Excel.Visible := False;
    //ShowProgress(OutputLabel, 'Exceldatei wird geöffnet...');
    Workbook := Excel.Workbooks.Open(ExcelFile);
    Sheet := Workbook.Worksheets[1];

    //ShowProgress(OutputLabel, 'Prüfe Excel Inventarliste...');

    // --- Vorabprüfung: letzte Zeile ermitteln ---
    Row := 2;
    while True do
    begin
      if VarIsEmpty(Sheet.Cells[Row, 1].Value) and
         VarIsEmpty(Sheet.Cells[Row, 2].Value) and
         VarIsEmpty(Sheet.Cells[Row, 3].Value) and
         VarIsEmpty(Sheet.Cells[Row, 4].Value) and
         VarIsEmpty(Sheet.Cells[Row, 5].Value) and
         VarIsEmpty(Sheet.Cells[Row, 6].Value) and
         VarIsEmpty(Sheet.Cells[Row, 7].Value) and
         VarIsEmpty(Sheet.Cells[Row, 8].Value) then
        Break;


      // Kaufdatum prüfen
      if not VarIsNull(Sheet.Cells[Row, 1].Value) then
      begin
        try
          KaufDT := Sheet.Cells[Row, 1].Value;
        except
          raise Exception.CreateFmt('Ungültiges Kaufdatum in Zeile %d', [Row]);
        end;
      end;

      // SKU prüfen
      if Trim(VarToStr(Sheet.Cells[Row, 2].Value)) = '' then
        raise Exception.CreateFmt('Ungültige SKU in Zeile %d', [Row]);

      // Einkaufswert prüfen
      try
        EinkaufswertCent := ExcelEuroToCent(Sheet.Cells[Row, 3].Value);
      except
        raise Exception.CreateFmt('Ungültiger Einkaufswert in Zeile %d', [Row]);
      end;

      // Verkaufsdatum prüfen
      if not VarIsNull(Sheet.Cells[Row, 4].Value) and
         (Trim(VarToStr(Sheet.Cells[Row, 4].Value)) <> '') then
      begin
        try
          VerkaufDT := Sheet.Cells[Row, 4].Value;
        except
          raise Exception.CreateFmt('Ungültiges Verkaufsdatum in Zeile %d', [Row]);
        end;
      end;

      // Verkaufswert prüfen
      try
        VerkaufswertCent := ExcelEuroToCent(Sheet.Cells[Row, 5].Value);
      except
        raise Exception.CreateFmt('Ungültiger Verkaufswert in Zeile %d', [Row]);
      end;

      // Steuerbetrag prüfen
      try
        SteuerbetragCent := ExcelEuroToCent(Sheet.Cells[Row, 6].Value);
      except
        raise Exception.CreateFmt('Ungültiger Steuerbetrag in Zeile %d', [Row]);
      end;

      Inc(Row);
      if Row mod 50 = 0 then
        ShowProgress(OutputLabel, Format('Prüfe Zeile %d...', [Row]));
    end;

    ShowProgress(OutputLabel, 'Importiere Excel Inventarliste in Datenbank...');

    AConnection.StartTransaction;
    try
      Row := 2; // Kopfzeile überspringen
      while True do
      begin
        if VarIsEmpty(Sheet.Cells[Row, 1].Value) and
           VarIsEmpty(Sheet.Cells[Row, 2].Value) and
           VarIsEmpty(Sheet.Cells[Row, 3].Value) and
           VarIsEmpty(Sheet.Cells[Row, 4].Value) and
           VarIsEmpty(Sheet.Cells[Row, 5].Value) and
           VarIsEmpty(Sheet.Cells[Row, 6].Value) and
           VarIsEmpty(Sheet.Cells[Row, 7].Value) and
           VarIsEmpty(Sheet.Cells[Row, 8].Value) then
          Break;

        // --- Kaufdatum ---
        if not VarIsNull(Sheet.Cells[Row, 1].Value) and
           (Trim(VarToStr(Sheet.Cells[Row, 1].Value)) <> '') then
        begin
          try
            KaufDT := Sheet.Cells[Row, 1].Value;
            TSKauf := DateTimeToUnix(KaufDT);
          except
            TSKauf := DateTimeToUnix(EncodeDate(1970,1,1));
          end;
        end
        else
          TSKauf := DateTimeToUnix(EncodeDate(1970,1,1));

        // --- SKU ---
        SKU := VarToStr(Sheet.Cells[Row, 2].Value);

        // --- Einkaufswert ---
        EinkaufswertCent := ExcelEuroToCent(Sheet.Cells[Row, 3].Value);

        // --- Verkaufsdatum ---
        if not VarIsNull(Sheet.Cells[Row, 4].Value) and
           (Trim(VarToStr(Sheet.Cells[Row, 4].Value)) <> '') then
        begin
          try
            VerkaufDT := Sheet.Cells[Row, 4].Value;
            TSVerkauf := DateTimeToUnix(VerkaufDT);
          except
            TSVerkauf := DateTimeToUnix(EncodeDate(1970,1,1));
          end;
        end
        else
          TSVerkauf := DateTimeToUnix(EncodeDate(1970,1,1));

        // --- Verkaufswert ---
        VerkaufswertCent := ExcelEuroToCent(Sheet.Cells[Row, 5].Value);

        // --- Steuerbetrag ---
        SteuerbetragCent := ExcelEuroToCent(Sheet.Cells[Row, 6].Value);

        // --- Spalte 7 ---
        S7 := Trim(VarToStr(Sheet.Cells[Row, 7].Value));
        RechnungsNr := '';
        EinkaufBemerkung := '';

        if S7 <> '' then
        begin
          if IsPureInteger(S7) then //RechnungsNr
            RechnungsNr := S7
          else
            EinkaufBemerkung := S7; //Wert aus RechnungsNr in EinkaufBemerkung schreiben
        end;

        // --- Spalte 8 ---
        S8 := Trim(VarToStr(Sheet.Cells[Row, 8].Value));
        VerkaufsBemerkung := '';
        Einheit := '';
        if (S8 <> '') AND (length(S8) > 6) then
          VerkaufsBemerkung := S8
        else if(length(S8)<=6) then  //Wert aus RechnungsNr in Einheiten schreiben
            Einheit := S8;

        // --- INSERT ---
        with TFDQuery.Create(nil) do
        try
          Connection := AConnection;
          SQL.Text :=
            'INSERT INTO inventar (' +
            'Einkaufsdatum, SKU, Einkaufswert, EinkaufBemerkung, ' +
            'Verkaufsdatum, Verkaufswert, VerkaufBemerkung, Steuerbetrag, ' +
            'RechnungsNr, Einheit' +
            ') VALUES (' +
            ':ED, :SKU, :EW, :EB, :VD, :VW, :VB, :ST, :RN, :EI)';

          if TSKauf > 0 then
            ParamByName('ED').AsLargeInt := TSKauf
          else
            with ParamByName('ED') do
            begin
              DataType := ftLargeInt;
              Clear;
            end;

          ParamByName('SKU').AsString := SKU;
          ParamByName('EW').AsLargeInt := EinkaufswertCent;

          if TSVerkauf > 0 then
            ParamByName('VD').AsLargeInt := TSVerkauf
          else
            with ParamByName('VD') do
            begin
              DataType := ftLargeInt;
              Clear;
            end;

          ParamByName('VW').AsLargeInt := VerkaufswertCent;
          ParamByName('ST').AsLargeInt := SteuerbetragCent;
          ParamByName('RN').AsString := RechnungsNr;
          ParamByName('EB').AsString := EinkaufBemerkung;
          ParamByName('VB').AsString := VerkaufsBemerkung;
          ParamByName('EI').AsString := Einheit;

          ExecSQL;
        finally
          Free;
        end;

        Inc(Row);
        if Row mod 50 = 0 then
          ShowProgress(OutputLabel, Format('Importiere Zeile %d...', [Row]));
      end;

      AConnection.Commit;
      ShowProgress(OutputLabel, 'Import abgeschlossen.');
    except
      AConnection.Rollback;
      raise;
    end;

  finally
    Workbook.Close(False);
    Excel.Quit;
    Excel := Unassigned;
    if Assigned(OutputLabel) then
      OutputLabel.Caption := '';
  end;
end;









procedure ImportCSVToInventar(const AConnection: TFDConnection; const CSVFile: string; OutputLabel: TLabel);
var
  Excel, Workbook, Sheet: OleVariant;
  Row: Integer;

  KaufDT, VerkaufDT: TDateTime;
  TSKauf, TSVerkauf: Int64;

  SKU, RechnungsNr, Einheit, EinkaufBemerkung, VerkaufBemerkung: string;
  EinkaufswertCent, VerkaufswertCent, SteuerbetragCent: Int64;

  function IsPureInteger(const S: string): Boolean;
  var
    I: Integer;
  begin
    Result := TryStrToInt(S, I);
  end;

begin
  // Sofort Meldung ausgeben, bevor Excel geladen wird
  ShowProgress(OutputLabel, 'Import der CSV-Datei in die Datenbank wird vorbereitet...');

  Excel := CreateOleObject('Excel.Application');
  try
    Excel.Visible := False;
    ShowProgress(OutputLabel, 'CSV-Datei wird geöffnet...');
    Workbook := Excel.Workbooks.Open(CSVFile);
    Sheet := Workbook.Worksheets[1];

    ShowProgress(OutputLabel, 'Prüfe CSV Inventarliste...');

    // --- Vorabprüfung: letzte Zeile ermitteln ---
    Row := 2;
    while True do
    begin
      if VarIsEmpty(Sheet.Cells[Row, 1].Value) and //Kaufdatum
         VarIsEmpty(Sheet.Cells[Row, 2].Value) and //SKU
         VarIsEmpty(Sheet.Cells[Row, 3].Value) and //Einheit
         VarIsEmpty(Sheet.Cells[Row, 4].Value) and //St. Frei Betrag - Einkaufsdatum
         VarIsEmpty(Sheet.Cells[Row, 5].Value) and //Einkauf Bemerkung
         VarIsEmpty(Sheet.Cells[Row, 6].Value) and //Verkaufsdatum
         VarIsEmpty(Sheet.Cells[Row, 7].Value) and //Verkaufsbetrag
         VarIsEmpty(Sheet.Cells[Row, 8].Value) and //Verkauf Bemerkung
         VarIsEmpty(Sheet.Cells[Row, 9].Value) and //Zu besteuernder betrag
         VarIsEmpty(Sheet.Cells[Row, 10].Value) then //RechnungsNr
        Break;

      // Kaufdatum prüfen
      if not VarIsNull(Sheet.Cells[Row, 1].Value) then
      begin
        try
          KaufDT := Sheet.Cells[Row, 1].Value;
        except
          raise Exception.CreateFmt('Ungültiges Kaufdatum in Zeile %d', [Row]);
        end;
      end;

      // SKU prüfen
      if Trim(VarToStr(Sheet.Cells[Row, 2].Value)) = '' then
        raise Exception.CreateFmt('Ungültige SKU in Zeile %d', [Row]);

      // Einkaufswert prüfen
      try
        EinkaufswertCent := ExcelEuroToCent(Sheet.Cells[Row, 4].Value);
      except
        raise Exception.CreateFmt('Ungültiger Einkaufswert in Zeile %d', [Row]);
      end;

      // Verkaufsdatum prüfen
      if not VarIsNull(Sheet.Cells[Row, 6].Value) and
         (Trim(VarToStr(Sheet.Cells[Row, 6].Value)) <> '') then
      begin
        try
          VerkaufDT := Sheet.Cells[Row, 6].Value;
        except
          raise Exception.CreateFmt('Ungültiges Verkaufsdatum in Zeile %d', [Row]);
        end;
      end;

      // Verkaufswert prüfen
      try
        VerkaufswertCent := ExcelEuroToCent(Sheet.Cells[Row, 7].Value);
      except
        raise Exception.CreateFmt('Ungültiger Verkaufswert in Zeile %d', [Row]);
      end;

      // Steuerbetrag prüfen
      try
        SteuerbetragCent := ExcelEuroToCent(Sheet.Cells[Row, 9].Value);
      except
        raise Exception.CreateFmt('Ungültiger Steuerbetrag in Zeile %d', [Row]);
      end;

      Inc(Row);
      if Row mod 50 = 0 then
        ShowProgress(OutputLabel, Format('Prüfe Zeile %d...', [Row]));
    end;

    ShowProgress(OutputLabel, 'Importiere Excel Inventarliste in Datenbank...');

    AConnection.StartTransaction;
    try
      Row := 2; // Kopfzeile überspringen
      while True do
      begin
        if VarIsEmpty(Sheet.Cells[Row, 1].Value) and //Kaufdatum
           VarIsEmpty(Sheet.Cells[Row, 2].Value) and //SKU
           VarIsEmpty(Sheet.Cells[Row, 3].Value) and //Einheit
           VarIsEmpty(Sheet.Cells[Row, 4].Value) and //St. Frei Betrag - Einkaufswert
           VarIsEmpty(Sheet.Cells[Row, 5].Value) and //Einkauf Bemerkung
           VarIsEmpty(Sheet.Cells[Row, 6].Value) and //Verkaufsdatum
           VarIsEmpty(Sheet.Cells[Row, 7].Value) and //Verkaufsbetrag
           VarIsEmpty(Sheet.Cells[Row, 8].Value) and //Verkauf Bemerkung
           VarIsEmpty(Sheet.Cells[Row, 9].Value) and //Zu besteuernder Betrag
           VarIsEmpty(Sheet.Cells[Row, 10].Value) then //RechnungsNr
          Break;

        // --- Kaufdatum ---
        if not VarIsNull(Sheet.Cells[Row, 1].Value) and
           (Trim(VarToStr(Sheet.Cells[Row, 1].Value)) <> '') then
        begin
          try
            KaufDT := Sheet.Cells[Row, 1].Value;
            TSKauf := DateTimeToUnix(KaufDT);
          except
            TSKauf := DateTimeToUnix(EncodeDate(1970,1,1));
          end;
        end
        else
          TSKauf := DateTimeToUnix(EncodeDate(1970,1,1));


        SKU := VarToStr(Sheet.Cells[Row, 2].Value);
        Einheit := VarToStr(Sheet.Cells[Row, 3].Value);
        EinkaufswertCent := ExcelEuroToCent(Sheet.Cells[Row, 4].Value);
        EinkaufBemerkung := VarToStr(Sheet.Cells[Row, 5].Value);

        // --- Verkaufsdatum ---
        if not VarIsNull(Sheet.Cells[Row, 6].Value) and
           (Trim(VarToStr(Sheet.Cells[Row, 6].Value)) <> '') then
        begin
          try
            VerkaufDT := Sheet.Cells[Row, 6].Value;
            TSVerkauf := DateTimeToUnix(VerkaufDT);
          except
            TSVerkauf := DateTimeToUnix(EncodeDate(1970,1,1));
          end;
        end
        else
          TSVerkauf := DateTimeToUnix(EncodeDate(1970,1,1));


        VerkaufswertCent := ExcelEuroToCent(Sheet.Cells[Row, 7].Value);
        VerkaufBemerkung := VarToStr(Sheet.Cells[Row, 8].Value);
        SteuerbetragCent := ExcelEuroToCent(Sheet.Cells[Row, 9].Value);
        RechnungsNr := Trim(VarToStr(Sheet.Cells[Row, 10].Value));


        // --- INSERT ---
        with TFDQuery.Create(nil) do
        try
          Connection := AConnection;
          SQL.Text :=
            'INSERT INTO inventar (' +
            'Einkaufsdatum, SKU, Einkaufswert, EinkaufBemerkung, ' +
            'Verkaufsdatum, Verkaufswert, VerkaufBemerkung, Steuerbetrag, ' +
            'RechnungsNr, Einheit' +
            ') VALUES (' +
            ':ED, :SKU, :EW, :EB, :VD, :VW, :VB, :ST, :RN, :EI)';

          if TSKauf > 0 then
            ParamByName('ED').AsLargeInt := TSKauf
          else
            with ParamByName('ED') do
            begin
              DataType := ftLargeInt;
              Clear;
            end;

          ParamByName('SKU').AsString := SKU;
          ParamByName('EW').AsLargeInt := EinkaufswertCent;

          if TSVerkauf > 0 then
            ParamByName('VD').AsLargeInt := TSVerkauf
          else
            with ParamByName('VD') do
            begin
              DataType := ftLargeInt;
              Clear;
            end;

          ParamByName('VW').AsLargeInt := VerkaufswertCent;
          ParamByName('ST').AsLargeInt := SteuerbetragCent;
          ParamByName('RN').AsString := RechnungsNr;
          ParamByName('EB').AsString := EinkaufBemerkung;
          ParamByName('VB').AsString := VerkaufBemerkung;
          ParamByName('EI').AsString := Einheit;

          ExecSQL;
        finally
          Free;
        end;

        Inc(Row);
        if Row mod 50 = 0 then
          ShowProgress(OutputLabel, Format('Importiere Zeile %d...', [Row]));
      end;

      AConnection.Commit;
      ShowProgress(OutputLabel, 'Import abgeschlossen.');
    except
      AConnection.Rollback;
      raise;
    end;

  finally
    Workbook.Close(False);
    Excel.Quit;
    Excel := Unassigned;
    if Assigned(OutputLabel) then
      OutputLabel.Caption := '';
  end;
end;








end.
